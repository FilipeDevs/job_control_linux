\section{Terminales de contrôle}
Un terminal de contrôle est un terminal spécial associé à une session de processus. Il sert de point de communication principal entre une session et l'utilisateur, permettant aux processus de cette session d'interagir avec l'utilisateur via le terminal. Tous les processus d’une session peuvent avoir un seul et unique terminal de contrôle.

\subsection{Association à un terminal de contrôle}

Comme expliqué précedemment, lorsqu'une nouvelle session est créée, le processus leader de cette session n'a pas encore de connexion au terminal de contrôle. En d'autres termes, à sa création, une session ne dispose pas encore d'un terminal de contrôle associé.
\newline
Pour qu'une session puisse établir une connexion avec un terminal de contrôle, le processus leader de cette session doit ouvrir un nouveau terminal de contrôle. Il est essentiel de noter que ce terminal ne doit en aucun cas être déjà associé à une autre session. 
\newline
Lorsque le leader de la session réussit à établir cette connexion avec le terminal, il devient ce que l'on appelle le "processus contrôleur". Les détails sur les implications de ce rôle seront expliqués dans la suite. 
\newline
Tous les processus dans une session héritent de l’accès du terminal de contrôle. 
Habituellement, les nouvelles sessions sont créées par le programme de login du système et le leader de la session est le processus exécutant le shell de login de l'utilisateur.

\subsection{Le signal SIGHUP}

Lorsqu’une session (c’est-à-dire le processus contrôleur) perd son terminal de contrôle ou le processus contrôleur se termine (fermeture de la fenêtre du terminal par exemple), tous les processus de la session perdent également leur association à ce terminal de contrôle. 
\newline
Pour les informer de cet évènement, le noyau envoie un signal (SIGHUP) au processus contrôleur, qui lui-même va créer une réaction en chaine en envoyant SIGHUP à tous les groupes de processus que lui-même a créé, à noter que ce signal ne sera pas envoyé à des groupes de processus (jobs) qui n’ont pas été créées par le processus contrôleur ! 
\newline
Le signal SIGHUP, par défaut termine un programme, mais celui-ci peut bien sur créer un handler, et continuer à s’exécuter (pour faire des opérations de nettoyage par exemple). Le signal SIGCONT peut éventuellement être envoyé s’il y avait des processus stoppés lorsque qu’il y a la dissociation du terminal de contrôle. 
\subsubsection{\textit{nohup}}
Une commande particulière qui permet d’ignorer le signal SIGHUP, est la commande \textit{nohup}. Cette commande permet d’exécuter un processus/job et ignorer SIGHUP, même lorsque le processus de contrôle ou le terminal de contrôle se termine (comme expliqué précédemment ces deux évènements génèrent le signal SIGHUP). Tout output généré par le processus/job sera redirigé vers nohup.out. Et bien sûr si le processus/job essaye de lire depuis le terminal de contrôle alors que celui-ci n’existe plus, une erreur sera retourné.