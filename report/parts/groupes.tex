\section{Groupes de Processus}
Un groupe de processus est une collection d’un ou plusieurs processus qui partagent un identifiant de groupe de processus (PGID) commun. L'identifiant de groupe de processus (PGID) est un numéro de type \textit{pid\_t}, similaire à l'identifiant de processus (PID). 
\newline
Chaque groupe de processus est dirigé par un chef de groupe de processus, qui est le processus responsable de la création du groupe et dont l'identifiant de processus (PID) devient l'identifiant de groupe de processus (PGID) du groupe. Lorsqu'un nouveau processus est créé, il hérite automatiquement de l'identifiant de groupe de processus (PGID) de son processus parent.
\newline

\subsection{L’appel système \textit{setpgid()}}

La création d'un nouveau groupe de processus, essentielle dans le contrôle des jobs, est réalisée via l'appel système \textit{setpgid()} . Cette fonction permet de changer le groupe de processus d'un processus existant ou de créer un groupe totalement nouveau.

\begin{lstlisting}[frame=single]
#include <unistd.h>

int setpgid(pid_t pid, pid_t pgid);
\end{lstlisting}

L’appel système \textit{setpgid()} modifie le groupe de processus d'un processus existant ou crée un nouveau groupe. Les paramètres \textit{pid} et \textit{pgid} déterminent le processus et le nouveau PGID respectivement. Si ces paramètres spécifient le même processus, un nouveau groupe est créé, avec le processus spécifié en tant que leader.

Une restriction importante est que le PGID d'un enfant ne peut pas être modifié après un \textit{exec()}, déclenchant une erreur EACCES si tenté.

\subsubsection{Contraintes dans le contrôle de jobs}

La restriction interdisant à un processus de modifier l'identifiant du groupe de processus (PGID) de l'un de ses enfants après qu'il ait effectué un exec() influence la conception des shells de contrôle de jobs.
\newline
Il est essentiel de souligner que tous les processus d'un job (une commande ou un pipeline) doivent être regroupés dans un unique groupe de processus. Cela permet au shell d'envoyer simultanément des signaux de contrôle de job à tous les membres du groupe de processus. Naturellement, cette étape doit être réalisée avant l'émission de tout signal de contrôle de tâche !
\newline
Ainsi, chaque job (processus enfant) doit être assigné à un groupe de processus avant l'exécution d'un programme, car le programme lui-même n'a pas connaissance des modifications de l'identifiant du groupe de processus.
\newline
Pour chaque processus dans la tâche, soit le shell (parent), soit le job (enfant) pourrait utiliser setpgid() pour modifier l'identifiant du groupe de processus du job (enfant). Toutefois, en raison de l'imprévisibilité de l'ordonnanceur après un fork(), il n'est pas garanti que le shell changera l'identifiant du groupe de processus du nouveau job avant que ce dernier n'effectue un exec(). De même, on ne peut pas être assuré que le job (enfant) modifiera son identifiant de groupe de processus avant que le shell (parent) ne tente d'envoyer des signaux de contrôle de job. Par conséquent, les shells de contrôle de job sont conçus pour que le shell lui-même et le job (processus enfant) appellent tous deux setpgid() afin de modifier l'identifiant du groupe de processus du job à la même valeur immédiatement après un fork(). Le parent ignore toute occurrence de l'erreur EACCES lors de l'appel à setpgid().
\newline

\subsection{L’appel système \textit{getpgrp()} }
Chaque processus possède un identifiant de groupe de processus qui définit le groupe de processus auquel il appartient (PGID). Un nouveau processus hérite de l'identifiant de groupe de processus de son parent. Un processus peut obtenir son identifiant de groupe de processus en utilisant getpgrp(). Si la valeur renvoyée par getpgrp() correspond à l'ID du processus appelant, cela signifie que ce processus est le leader de son groupe de processus.
\newline
\begin{lstlisting}[frame=single]
#include <unistd.h>

pid_t getpgrp(void);
\end{lstlisting}
