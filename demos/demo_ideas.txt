==== Idées de Demos ====

DEMO/TEST 1 (Groupes et Sessions)

=> Monter que le shell (le leader de session SID=PID) à chaque nouveau job (commande ou pipeline) executé, celui-ci
sera placé dans un nouveau groupe (mais reste bien sur dans la meme session que le bash)

$ echo $$
$ sleep 10 &
$ sleep 10 | ls &
$ ps -o 'pid ppid pgid sid comm'

=> ps va montrer que les 2 sleep sont placés dans des groupes différents (PGID diff) et leurs SID reste le meme
(meme PID que le bash)


DEMO/TEST 2 (SIGHUP v1, shell se termine)

=> Demontrer le signal SIGHUP. Créer un bete programme qui fait un pause() + un handler pour SIGHUP et print sa réception.
Puis lancer ce programme dans le shell + redirection vers un fichier log et exit le shell. Les logs vont bien montrer
que le programme a recu SIGHUP envoyé par le shell (SIGHUP termine le processus par défaut, mais il est possible de l'ignorer 
et continuer à tourner, mais attention le processus n'a plus accés au terminal !)

Observations : Le shell evoie SIGHUP qu'aux groupes de process qu'il a créé (qu'il est au courant)

DEMO/TEST 3 (SIGHUP v2, groupes de processus orphelins)

=> Suite à la demo 2, ici démontrer une autre occurence de SIGHUP. La mort du processus de controle (shell) n'est pas le seul
moyen de faire le noyau envoyer un SIGHUP. Il existe une occurrence particuliere qu'on apelle groupes de process orphelins.

Créér programme qui plsrs fils + handler de SIGHUP et print de sa réception. Le pere exit (leader du groupe se termine !) 
Le shell enlenve ansi le leader du groupe de sa liste de jobs (resultat ? Les fils créés auparavant par le leader du groupe sont toujours la 
mais le shell ne l'observe plus !!! => groupe de process orphelin). Le noyau reconnait cette situation et envoie SIGHUP à tous 
les process de ce groupe de process orphelins.

Observations : SIGCONT est aussi envoyé si un des process de ce groupe orphelin était stoppé => sinon il sera tjrs stoppé à jamais :(.


DEMO/TEST 4 (Accés au terminal)

=> Démonter l'accés au terminal de controle pour les processus en bg.

1. Lancer un job en bg qui tente de lire stdin du terminal (cat > output.txt &, par exemple). 
Un signal SIGINT est envoyé et le job est stoppé (SIGINT stoppe le job par defaut).

(A savoir que SIGINT n'est pas une erreur mais bien un signal ! Si le process ignore SIGINT et tente quand meme
de lire stdin du terminal alors la une vrai erreur (EIO) est retourné)

2. Lancer un job en bg qui affiche du contenu dans stdout du terminal (ls -a &, par exemple).
Le job n'est pas stoppé et le contenu est bien affiché.

(Par defaut les process en bg ne recoivent pas de signal lorsqu'ils tent de afficher sur stdout, mais 
si le flag TOSTOP est levé un signal SIGTTOU est envoyé au processus (et comme SIGINT, SIGTTOU stoppe le job par
defaut)
